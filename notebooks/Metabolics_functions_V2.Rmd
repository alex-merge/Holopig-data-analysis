---
title: "Metabolic_functions_analysis"
output: html_notebook
---

# Metabolic functions analysis

The current notebook explains how to handle data in order to get the relative abundance of functions (enzymes, GO, ...) and differentiate it by the class of the individual (control or colistin).

## Import libraries

```{r}
library(ggplot2)
library(hrbrthemes)
library(tidyverse)
library(tidyr)
library(RColorBrewer)
library(reshape)
```

## Association between the piglet and its condition

We associate two lists :

-   `name_sample` : names of the piglet which appear in columns. The name and the column need to be the same because we use the name_sample as a variable to get all the individuals in further parts.

-   `catogory` : class of the piglet. The vector begins with the category of the firs piglet, the last category given corresponds to the last piglet (here the 34th piglet) .

```{r}

name_sample = c() #empty list

for (nb_pig in 1:34) {
  if (nb_pig < 10){
    name_sample = c(name_sample, paste("Holopig_colon0", nb_pig, ".featureCounts.tsv", sep = ""))
  } else {
    name_sample = c(name_sample, paste("Holopig_colon", nb_pig, ".featureCounts.tsv", sep = ""))
  }
}
category = c("Control", "Colistin", "Control", "Control", "Control", "Control",
             "Colistin", "Colistin", "Control", "Colistin", "Colistin", "Control",
             "Control", "Control", "Control", "Control", "Control", "Colistin",
             "Colistin", "Colistin", "Colistin", "Colistin", "Control", "Control",
             "Control", "Control", "Control", "Colistin", "Control", "Colistin",
             "Colistin", "Colistin", "Colistin", "Colistin")

data_cat_sample = data.frame(name_sample, category)
```

From this we transpose the data frame to get each piglet name's as columns and the category as the value of the row. It will be further used for the creation of heatmaps.

```{r}
# Add the category of the pig (colistin or control)
transposed_cat_pig = t(data_cat_sample)
dataframe_pig_cat = data.frame(transposed_cat_pig)
names(dataframe_pig_cat) = as.matrix(dataframe_pig_cat[1,]) #make the first row as the header
dataframe_pig_cat = dataframe_pig_cat[-1,] #remove the first row now
```

## Settings to load the preprocessed data

Put the output prefix used in /scripts/Raw_data_splitter in `pattern =` . Be careful the current working directory is not the general folder. Then you need to escape it (..) and enter in the folder where there are the split files from raw metabolic data (/refined_data). The list of the files is saved in the directory variable.

```{r}

directory=list.files(path = "../refined_data", pattern = "Annot") #Retrieve file name in path witch contains the pattern
```

### Sum of reads per individual

We set up an empty data frame (`nb_reads_pig`) in order to get the total sum of reads per individual. It will be further use for calculating the relative abundance.

```{r}

columns_reads = c(name_sample)
rows_reads    = c(directory)
nb_reads_pig  = data.frame(matrix(nrow = length(directory), ncol = length(columns_reads)))
colnames(nb_reads_pig) = columns_reads
rownames(nb_reads_pig) = rows_reads

for (file in directory) {
  
  # Manipulation of each split file
  filepath  = paste("../refined_data/", file, sep = "")
  data      = read.csv(filepath, sep = ";")
  
  # Counter of total reads for each pig in each file
  for (name_pig in name_sample) {
    sum_reads_pig = sum(na.omit(data[, colnames(data)[colnames(data) == name_pig]]))
    nb_reads_pig[file, name_pig] = sum_reads_pig
  }
}

nb_reads_pig[nrow(nb_reads_pig)+1,] = colSums(nb_reads_pig)
rownames(nb_reads_pig)[nrow(nb_reads_pig)] = 'Total'

```

### Removing useless variables

Clean up the environment to remove useless variables. Optional step.

```{r}
rm(list = c("category", "columns_reads", "file", "filepath", "name_pig", "nb_pig", "rows_reads", "sum_reads_pig"))
```

## Work on the split files

To treat the data is an easier way, we have split it in different files and now we want to aggregate the data of interest little by little, file per file. To do so, we use a for-loop to look at each file. Loading the complete raw data is longer than loading several smaller files.

### Relative Abundance

Creating empty data frame. Will be use in the for-loop to store the filtered data.

```{r}
columns_filtered = c(name_sample, "COG_category", "GOs", "EC", "KEGG_ko", "KEGG_Pathway", "KEGG_Reaction", "CAZy", "PFAMs","KEGG_Module")
data_filtered = data.frame(matrix(nrow = 0, ncol = length(columns_filtered)))
colnames(data_filtered) = columns_filtered

```

1.  We remove unnecessary columns and rows with Sum = 0 (genes where no reads mapped)
2.  We calculate the relative abundance per individuals.
3.  We only select rows which present more than 8 values for a single group. This means if the colistin group gets more than 8 values (i.e. values different from 0), we keep the entire row. If the colistin group gets less than 8 values but the control group does, we keep the entire row. But neither the colistin group or the control group gets more than 8 values, we drop the row.

```{r}

for (file in directory) {
  
  # Manipulation of each split file
  filepath = paste("../refined_data/", file, sep = "")
  data = read.csv(filepath, sep = ";")
  
  data = data %>% select(-c(seed_cluster, seed_ortholog, evalue, score, BRITE, KEGG_Module, KEGG_rclass, KEGG_TC, BiGG_Reaction, eggNOG_OGs, max_annot_lvl, Description, sseqid, stitle))
  data_RelAbd_mod = subset(data, sum != 0)
  data_RelAbd_mod = data_RelAbd_mod %>% select(-sum)

  # Creating a new dataframe with relative abundances
  for (name in name_sample) {
  data_RelAbd_mod[,name] = data_RelAbd_mod[,name] / nb_reads_pig["Total",name] #Dividing each cell by the total of reads for the individual and add it to the new dataframe
  }
  # Giving up the rows if there is less than 8 values for both categories.(i.e. =/= 0)
  data_RelAbd_testColistin = data_RelAbd_mod %>% select(data_cat_sample$name_sample[data_cat_sample$category == "Colistin"]) %>% mutate(nb_empty_sample_Colisitin = rowSums(. == 0))
  data_RelAbd_testControl = data_RelAbd_mod %>% select(data_cat_sample$name_sample[data_cat_sample$category == "Control"]) %>% mutate(nb_empty_sample_Control = rowSums(. == 0))
  data_RelAbd_filtered = subset(data_RelAbd_mod, data_RelAbd_testColistin$nb_empty_sample_Colisitin <= 8 | data_RelAbd_testControl$nb_empty_sample_Control <= 8) #Keeping rows if there is less than 8 times 0 in one category
  
  # Binding the result from a file, one after the other
  data_filtered = merge(data_filtered,data_RelAbd_filtered, all = TRUE)

}

```

### Exportation of the filtered data

```{r}

write.table(data_filtered, file = "../refined_data/Quantifications_and_functional_annotations_filtered", sep = '\t', row.names = FALSE, quote = FALSE)

```

### Removing useless variables

Clean up the environment to remove useless variables. Optional step.

```{r}
rm(list = c("data", "data_RelAbd_filtered", "data_RelAbd_testColistin", "data_RelAbd_testControl", "data_RelAbd_mod", "file", "filepath", "name", "columns_filtered"))
```

## Getting dataframe for the selected function

All the processing before needs to be run one time. The following processing steps can be run several times (for each function of interest) one the same `data_filtered` dataframe because all the possible functions were kept.

### Setting the function of interest

The user needs to fill the type of function he has interest for. There is predetermined choices, it only could be the name of a column kept in the `data_filtered` data frame.

```{r}
#choose the function of interest
function_interest = c("COG_category") #several choices but one at the time
function_interest = c("GOs")
function_interest = c("KEGG_ko")
function_interest = c("KEGG_Pathway")
function_interest = c("KEGG_Reaction")
function_interest = c("CAZy")
function_interest = c("PFAMs")
function_interest = c("EC")
function_interest = c("KEGG_Module")

```

### Getting the sum of the relative abundances by the function

```{r}

# Keeping columns of interest and creating a new dataframe
functions_interest_data = data_filtered[,c(function_interest, name_sample)]
  
# Summing columns by the name of the function in a dataframe
functions_interest_data = aggregate(x = functions_interest_data[, colnames(functions_interest_data)[colnames(functions_interest_data) != function_interest ]],list(functions_interest_data[,function_interest]), FUN=sum)
colnames(functions_interest_data)[colnames(functions_interest_data) == 'Group.1'] <- function_interest
  
```

### Aggregating same functions

Depending on the type of function of interest, sometimes a same row describe different functions. It's because the annotation at the first place was double, triple, ... . So we need to separate the rows by their categories but the separator depends of the type of function, we use an if-loop to go through each case.

```{r}

if (function_interest == "COG_category") {
  functions_interest_data_sum = separate_rows(functions_interest_data, function_interest, sep = "", convert = TRUE)
  
  functions_interest_data_sum[, function_interest][functions_interest_data_sum[, function_interest]==""] <- NA

  functions_interest_data_sum = na.omit(functions_interest_data_sum)

} else if (function_interest == "GOs" | function_interest == "EC" | function_interest == "KEGG_ko" | function_interest == "KEGG_Pathway" | function_interest == "KEGG_Reaction" | function_interest == "CAZy" | function_interest == "PFAMs" | function_interest == "KEGG_Module") {
  functions_interest_data_sum = separate_rows(functions_interest_data, function_interest, sep = ",", convert = TRUE)
}

```

Relative abundances stay the same for separate rows, we have re-sum the relative abundances by the name of the function. We have dropped duplicated rows which present a NA value in the function name (problem only with the manner of the COG_category was created in the raw data).

```{r}

# Summing columns by the name of the function in a dataframe
functions_interest_final_dataframe = aggregate(x = functions_interest_data_sum[, colnames(functions_interest_data_sum)[colnames(functions_interest_data_sum) != function_interest]], by = functions_interest_data_sum[, function_interest], FUN=sum)

functions_interest_final_dataframe[(grepl("-", functions_interest_final_dataframe[,function_interest])),function_interest] <- 'Unclassified'


```

### Removing useless variables

Clean up the environment to remove useless variables. Optional step.

```{r}
rm(list = c("functions_interest_data","functions_interest_data_sum"))
```

## Plotting heatmap for the selected functions

### Importing the database for the correspondence

We use a database to get the correspondence between the code in the data to a meaningful name. The user can choose which database will be use for a selected function.
/!\ : There are no corresponding tables (yet) for the GOs, KEGG_Reaction, CAZy and PFAMs.

```{r}

if (function_interest == "COG_category")  {
  functions_name_corresp = read.csv("../ressources/functions_COG_category.csv", sep = ";")
} else if (function_interest == "GOs")    {
  functions_name_corresp = read.csv("../ressources/.csv", sep = ";")
} else if (function_interest == "EC")     {
  functions_name_corresp = read.csv("../ressources/EC_equivalences_no_unknown.csv", sep = ";")
} else if (function_interest == "KEGG_ko")        {
  functions_name_corresp = read.csv("../ressources/KEGG_ko_final.csv", sep = ";")
} else if (function_interest == "KEGG_Pathway")   {
  functions_name_corresp = read.csv("../ressources/KEGG_pathway.csv", sep = ";")
} else if (function_interest == "KEEG_Reaction")  {
  functions_name_corresp = read.csv("../ressources/.csv", sep = ";")
} else if (function_interest == "CAZy")   {
  functions_name_corresp = read.csv("../ressources/.csv", sep = ";")
} else if (function_interest == "PFAMs")  {
  functions_name_corresp = read.csv("../ressources/.csv", sep = ";")
} else if (function_interest == "KEGG_Module")  {
  functions_name_corresp = read.csv("../ressources/KEGG_module.csv", sep = ";")
}
```

### Reshaping the data for the heatmap

A heatmap needs a certain shape for the data : four columns with the name of the function, its relative abundance per individuals and the category of the piglet (control or colistin).

```{r}

reshaped_functions = data.frame(matrix(nrow = 0, ncol = 4))
colnames(reshaped_functions) = c(function_interest,"Relative_abundance","Pig_name","Category")

for (name_pig in name_sample) {
  reshaped_functions_pig = data.frame(functions_interest_final_dataframe[,function_interest], functions_interest_final_dataframe[colnames(functions_interest_final_dataframe) == name_pig])
  reshaped_functions_pig['pig'] = rep(name_pig, length(functions_interest_final_dataframe[,function_interest]))
  reshaped_functions_pig['category'] = rep(dataframe_pig_cat[1,colnames(dataframe_pig_cat) == name_pig], length(functions_interest_final_dataframe[,function_interest]))
  colnames(reshaped_functions_pig)[colnames(reshaped_functions_pig) == name_pig] = 'relative_abundance'
  reshaped_functions = merge(reshaped_functions, reshaped_functions_pig, all = TRUE, by.y = c("functions_interest_final_dataframe...function_interest.","relative_abundance","pig","category"), by.x = c(function_interest,"Relative_abundance","Pig_name", "Category"))
}

```

Now we rename the piglet for a shorter name, make the correspondence with the database and rename functions with NA (former "-" functions).

```{r}

reshaped_functions = reshaped_functions %>% mutate(Pig_name = gsub("(\\D)*", "", Pig_name))

reshaped_functions[,function_interest] = functions_name_corresp$Definition_function[match(reshaped_functions[,function_interest], functions_name_corresp$Code_function)]

reshaped_functions[,function_interest] = replace_na(reshaped_functions[,function_interest],"Unclassified")

```

### Plotting heatmaps

```{r}

#definition of the value to print on the color scale
my_breaks = c(1e-7, 1e-6, 1e-5, 1e-4, 1e-3, 1e-2, 0.1, 1)

ggplot(reshaped_functions, aes(Pig_name, reorder(reshaped_functions[,function_interest], reshaped_functions$Relative_abundance), fill= Relative_abundance)) +
  geom_tile(colour = "white", size = 0.5) +
  scale_fill_gradientn(name = "count",# definition of the color gradient.
                    trans = "log", #chosing a logarythmic color scale
                    breaks = my_breaks, 
                    labels = my_breaks,
                    na.value = "#43A3B9",# plotting the 0 in the lowest color of the gradient
                    colours = c("#43A3B9",  "#D0EC97", "#FFFFBF", "#FD945D", "#DC4E51", "#370303")) +
  scale_y_discrete(expand=c(0, 0))+
  scale_x_discrete(expand=c(0, 0))+
  labs(fill="Sum of relative abundance", title = paste("Sum of relative abundance of", function_interest, "by piglet"))+ 
  theme_grey(base_size=12)+
  theme(line = element_blank(),
        axis.ticks.x = element_blank(),
        axis.text.x.bottom = element_text(face="bold.italic"),
        axis.text.y = element_text(face="bold.italic"),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        panel.border=element_blank(),
        legend.text=element_text(face="bold", size = 15),
        plot.title = element_text(face="bold", size = 20),
        legend.title = element_text(face="bold", size = 15),
        legend.key.size = unit(2, "cm"),
        strip.text.y = element_text(angle = 0, face = "bold", size = 15),
        strip.text.x = element_text(face = "bold", size = 15))+
  facet_grid(cols = vars(factor(reshaped_functions$Category, levels = c("Control", "Colistin"))),
             scales = "free",
             space = "free",
             labeller = )
scale = 200
ggsave(filename = paste("../export/HM_functions_", function_interest, ".png", sep = ""),
       width = 16*scale,
       height = 18*scale,
       units = "px",
       dpi=200)


```

A second heatmap is created, with the unknown data removed.

```{r}
reshaped_functions_no_unknown = reshaped_functions[-grep(pattern = 'unknown|Unclassified', reshaped_functions[,function_interest]),]

ggplot(reshaped_functions_no_unknown, aes(Pig_name, reorder(reshaped_functions_no_unknown[,function_interest], reshaped_functions_no_unknown$Relative_abundance), fill= Relative_abundance)) +
  geom_tile(colour = "white", size = 0.5) +
  scale_fill_gradientn(name = "count",# definition of the color gradient.
                    trans = "log", #chosing a logarythmic color scale
                    breaks = my_breaks, 
                    labels = my_breaks,
                    na.value = "#43A3B9",# plotting the 0 in the lowest color of the gradient
                    colours = c("#43A3B9",  "#D0EC97", "#FFFFBF", "#FD945D", "#DC4E51", "#370303")) +
  scale_y_discrete(expand=c(0, 0))+
  scale_x_discrete(expand=c(0, 0))+
  labs(fill="Sum of relative abundance", title = paste("Sum of relative abundance of", function_interest, "by piglet without unknown functions"))+ 
  theme_grey(base_size=12)+
  theme(line = element_blank(),
        axis.ticks.x = element_blank(),
        axis.text.x.bottom = element_text(face="bold.italic"),
        axis.text.y = element_text(face="bold.italic"),
        axis.title.x = element_blank(),
        axis.title.y = element_blank(),
        panel.border=element_blank(),
        legend.text=element_text(face="bold", size = 15),
        plot.title = element_text(face="bold", size = 20),
        legend.title = element_text(face="bold", size = 15),
        legend.key.size = unit(2, "cm"),
        strip.text.y = element_text(angle = 0, face = "bold", size = 15),
        strip.text.x = element_text(face = "bold", size = 15))+
  facet_grid(cols = vars(factor(reshaped_functions_no_unknown$Category, levels = c("Control", "Colistin"))),
             scales = "free",
             space = "free",
             labeller = )
scale = 200
ggsave(filename = paste("../export/HM_functions_", function_interest, "_no_unknown.png", sep = ""),
       width = 16*scale,
       height = 18*scale,
       units = "px",
       dpi=200)

```

### Removing useless variables for another function

If the user wants to re-run the production of heat maps, he needs to run the following command and go back to the point [Getting dataframe for the selected function].

```{r}
rm(list = c("functions_interest_final_dataframe","functions_name_corresp", "reshaped_functions", "reshaped_functions_no_unknown", "reshaped_functions_pig", "function_interest", "my_breaks", "scale"))
```


